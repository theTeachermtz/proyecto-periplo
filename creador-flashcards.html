<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creador de Flashcards - Periplo</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>
    
    <script type="module" src="https://esm.sh/run"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;900&display=swap'); 
        body { font-family: 'Nunito', sans-serif; }
        /* Animaciones suaves */
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">

    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Plus, Trash2, Save, FileText, Languages, Eraser, 
            Sparkles, Image as ImageIcon, Volume2, ArrowRightLeft, 
            Loader2, Play, AlertCircle, AlertTriangle, ArrowUp, ArrowDown,
            Copy, X, MessageSquare, CheckCircle, Settings, Eye, RefreshCw
        } from 'lucide-react';

        // --- üî• IMPORTANTE: TU CLAVE API VA AQU√ç ABAJO ---
        // P√©gala dentro de las comillas. Ejemplo: const apiKey = "AIzaSy...";
const apiKey = "AIzaSyD4d-Kx1jQbgrKIdeOftv7BM729m7MIGPo";

        const DashboardCreador = () => {
            // --- ESTADOS ---
            const generateUniqueId = () => {
                if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            };

            // Intentamos recuperar datos del men√∫ anterior si existen
            const [title, setTitle] = useState(localStorage.getItem('tempNewActivityName') || '');
            const [cards, setCards] = useState([
                { internalId: generateUniqueId(), front: '', back: '', image: null, audio: null }
            ]);
            
            const [isGeneratingList, setIsGeneratingList] = useState(false);
            const [aiPrompt, setAiPrompt] = useState('');
            const [loadingCards, setLoadingCards] = useState({});
            const [previewImage, setPreviewImage] = useState(null);
            const [bulkProgress, setBulkProgress] = useState({ current: 0, total: 0, type: null });
            
            const [imageContexts, setImageContexts] = useState({});
            const [activeContextId, setActiveContextId] = useState(null);
            const [tempContext, setTempContext] = useState("");
            
            const [toasts, setToasts] = useState([]);

            // Limpiar localStorage al cargar para no dejar basura
            useEffect(() => {
                localStorage.removeItem('tempNewActivityName');
            }, []);

            // --- HELPERS ---
            const addToast = (message, type = 'error') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => removeToast(id), 5000);
            };

            const removeToast = (id) => {
                setToasts(prev => prev.filter(t => t.id !== id));
            };

            const cleanJsonText = (text) => {
                return text.replace(/```json/g, '').replace(/```/g, '').trim();
            };

            const pcmToWav = (pcmBase64, sampleRate = 24000) => {
                const binaryString = atob(pcmBase64);
                const len = binaryString.length;
                const pcmData = new Int16Array(len / 2);
                for (let i = 0; i < len; i += 2) {
                    pcmData[i / 2] = (binaryString.charCodeAt(i + 1) << 8) | binaryString.charCodeAt(i);
                }
                const wavBuffer = new ArrayBuffer(44 + pcmData.length * 2);
                const view = new DataView(wavBuffer);
                const writeString = (o, s) => { for (let i = 0; i < s.length; i++) view.setUint8(o + i, s.charCodeAt(i)); };
                writeString(0, 'RIFF'); view.setUint32(4, 36 + pcmData.length * 2, true); writeString(8, 'WAVE'); writeString(12, 'fmt ');
                view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true); view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeString(36, 'data');
                view.setUint32(40, pcmData.length * 2, true);
                for (let i = 0; i < pcmData.length; i++) view.setInt16(44 + i * 2, pcmData[i], true);
                return URL.createObjectURL(new Blob([view], { type: 'audio/wav' }));
            };

            // --- API CALLS ---

            const generateListWithAI = async () => {
                if (!apiKey) return addToast("Error Cr√≠tico: API Key no inyectada. Edita el archivo y pon tu clave.", 'error');
                if (!aiPrompt.trim()) return;
                
                setIsGeneratingList(true);

                try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                    {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                        parts: [{
                            text: `Genera una lista de vocabulario JSON exacta sobre: "${aiPrompt}".
                            Formato: Array de objetos con "front" (Ingl√©s) y "back" (Espa√±ol). 
                            IMPORTANTE: Responde SOLAMENTE con el JSON raw.
                            Ejemplo: [{"front": "Apple", "back": "Manzana"}]`
                        }]
                        }],
                        generationConfig: { responseMimeType: "application/json" }
                    })
                    }
                );

                if (!response.ok) throw new Error(`Error ${response.status}`);

                const data = await response.json();
                const rawText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!rawText) throw new Error("La IA no devolvi√≥ texto.");

                const newItems = JSON.parse(cleanJsonText(rawText));

                if (Array.isArray(newItems)) {
                    const formattedItems = newItems.map(item => ({
                    internalId: generateUniqueId(),
                    front: item.front || '',
                    back: item.back || '',
                    image: null,
                    audio: null
                    }));
                    setCards(prev => [...prev, ...formattedItems]);
                    setAiPrompt('');
                    addToast("Lista generada con √©xito", 'success');
                }
                } catch (error) {
                console.error(error);
                addToast(error.message, 'error');
                } finally {
                setIsGeneratingList(false);
                }
            };

            const generateImageForCard = async (cardId, promptText) => {
                if (!apiKey) return addToast("API Key no detectada.", 'error');
                if (!promptText) return addToast("Escribe una palabra primero.", "warning");
                
                setLoadingCards(prev => ({ ...prev, [cardId]: 'image' }));

                const context = imageContexts[cardId] || "";
                const promptString = context 
                ? `Illustration of ${context} (representing "${promptText}"). Minimalist vector style, white background. NO TEXT.`
                : `Simple cartoon illustration of ${promptText}, white background, minimalist vector style. NO text inside.`;

                try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`,
                    {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        instances: [{ prompt: promptString }],
                        parameters: { sampleCount: 1 }
                    })
                    }
                );

                if (!response.ok) {
                    if (response.status === 401) throw new Error("Error 401: Auth fallida.");
                    const errText = await response.text();
                    throw new Error(`Error IMG ${response.status}: ${errText.substring(0, 50)}`);
                }

                const data = await response.json();
                const base64 = data.predictions?.[0]?.bytesBase64Encoded;
                
                if (!base64) throw new Error("La IA no gener√≥ imagen.");

                const imageUrl = `data:image/png;base64,${base64}`;
                setCards(cards => cards.map(c => c.internalId === cardId ? { ...c, image: imageUrl } : c));

                } catch (error) {
                console.error(error);
                if (!error.message.includes("401")) {
                    const userWantsContext = window.confirm(`No se pudo generar imagen. ¬øUsar contexto manual?`);
                    if (userWantsContext) handleOpenContextModal(cardId, imageContexts[cardId]);
                } else {
                    addToast(error.message, 'error');
                }
                } finally {
                setLoadingCards(prev => { const n = { ...prev }; delete n[cardId]; return n; });
                }
            };

            const generateAudioForCard = async (cardId, text) => {
                if (!apiKey) return addToast("API Key no detectada.", 'error');
                if (!text) return;
                
                setLoadingCards(prev => ({ ...prev, [cardId]: 'audio' }));

                let cleanText = text
                ?.replace(/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}]/gu, '') 
                .replace(/[^\w\s.,?!'-√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë()\/\[\]¬°¬ø]/g, ' ') 
                .replace(/\s+/g, ' ')
                .trim();

                if (!cleanText) {
                    setLoadingCards(prev => { const n = { ...prev }; delete n[cardId]; return n; });
                    return addToast("Texto inv√°lido para audio.", 'warning');
                }
                if (!/[.?!]$/.test(cleanText)) cleanText += ".";

                try {
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`,
                    {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: cleanText }] }],
                        generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } }
                        }
                    })
                    }
                );

                if (!response.ok) {
                    if (response.status === 401) throw new Error("Error 401: Auth fallida.");
                    const errText = await response.text();
                    throw new Error(`Error TTS ${response.status}: ${errText.substring(0, 50)}`);
                }

                const data = await response.json();
                const candidate = data.candidates?.[0];
                
                if (candidate?.finishReason && candidate.finishReason !== "STOP") {
                    throw new Error(`Audio filtrado (${candidate.finishReason})`);
                }
                
                const audioContent = candidate?.content?.parts?.[0]?.inlineData?.data;
                if (!audioContent) throw new Error("Sin datos de audio.");

                let sampleRate = 24000;
                const mime = candidate?.content?.parts?.[0]?.inlineData?.mimeType;
                if (mime && mime.match(/rate=(\d+)/)) sampleRate = parseInt(mime.match(/rate=(\d+)/)[1], 10);

                const audioUrl = pcmToWav(audioContent, sampleRate);
                setCards(cards => cards.map(c => c.internalId === cardId ? { ...c, audio: audioUrl } : c));

                } catch (error) {
                console.error(error);
                addToast(error.message, 'error');
                } finally {
                setLoadingCards(prev => { const n = { ...prev }; delete n[cardId]; return n; });
                }
            };

            // --- BULK ---

            const generateBulk = async (type) => {
                const cardsToProcess = cards.filter(c => c.front && !c[type]);
                if (cardsToProcess.length === 0) return addToast(`Nada pendiente de ${type}.`, 'info');
                
                setBulkProgress({ current: 0, total: cardsToProcess.length, type });

                for (let i = 0; i < cardsToProcess.length; i++) {
                const card = cardsToProcess[i];
                setBulkProgress(prev => ({ ...prev, current: i + 1 }));
                
                try {
                    if (type === 'image') {
                    await generateImageForCard(card.internalId, card.front);
                    } else {
                    await generateAudioForCard(card.internalId, card.front);
                    }
                } catch (e) {
                    if (e.message?.includes("401")) {
                    addToast("Error 401 masivo. Parando.", 'error');
                    break;
                    }
                }
                // Pausa simple
                await new Promise(r => setTimeout(r, 1000));
                }

                setBulkProgress({ current: 0, total: 0, type: null });
                addToast(`Proceso finalizado.`, 'success');
            };

            // --- OTROS HANDLERS ---

            const handleOpenContextModal = (cardId, currentContext) => {
                setActiveContextId(cardId);
                setTempContext(currentContext || "");
            };

            const handleSaveContext = () => {
                if (activeContextId) {
                setImageContexts(prev => ({ ...prev, [activeContextId]: tempContext }));
                setActiveContextId(null);
                addToast("Contexto guardado.", 'success');
                }
            };

            const playAudio = (url) => new Audio(url).play();

            // --- CRUD ---
            const handleAddCard = () => setCards([...cards, { internalId: generateUniqueId(), front: '', back: '', image: null, audio: null }]);
            const handleDuplicateCard = (index) => {
                const newCards = [...cards];
                newCards.splice(index + 1, 0, { ...cards[index], internalId: generateUniqueId() });
                setCards(newCards);
            };
            const handleInsertAfter = (index) => {
                const newCards = [...cards];
                newCards.splice(index + 1, 0, { internalId: generateUniqueId(), front: '', back: '', image: null, audio: null });
                setCards(newCards);
            };
            const handleMoveCard = (index, dir) => {
                if ((dir === 'up' && index === 0) || (dir === 'down' && index === cards.length - 1)) return;
                const newCards = [...cards];
                const target = dir === 'up' ? index - 1 : index + 1;
                [newCards[index], newCards[target]] = [newCards[target], newCards[index]];
                setCards(newCards);
            };
            const handleDeleteCard = (id) => {
                if (cards.length === 1) return setCards([{ internalId: generateUniqueId(), front: '', back: '', image: null, audio: null }]);
                setCards(cards.filter(c => c.internalId !== id));
            };
            const handleCardChange = (id, field, value) => setCards(cards.map(c => c.internalId === id ? { ...c, [field]: value } : c));
            const handleRemoveMedia = (id, type) => setCards(cards.map(c => c.internalId === id ? { ...c, [type]: null } : c));
            const handleSwapColumns = () => {
                if (confirm("¬øIntercambiar idiomas en todo?")) setCards(cards.map(c => ({ ...c, front: c.back, back: c.front })));
            };
            
            const handleSave = () => {
                if (!title.trim()) return addToast("A√±ade un t√≠tulo primero.", 'warning');
                const payload = {
                title,
                cards: cards.map((c, i) => ({ id: i + 1, front: c.front, back: c.back, image: c.image, audio: c.audio }))
                };
                console.log(JSON.stringify(payload, null, 2));
                
                // AQU√ç ES DONDE CONECTAREMOS CON LA BASE DE DATOS LUEGO
                // Por ahora, solo mostramos el √©xito
                addToast("Guardado (Simulaci√≥n - Check consola)", 'success');
                
                // Opcional: Volver al men√∫
                if(confirm("Juego guardado (simulado). ¬øVolver al men√∫?")) {
                    window.location.href = "/";
                }
            };
            
            const handleClearAll = () => {
                if (confirm("¬øBorrar todo?")) {
                setTitle('');
                setCards([{ internalId: generateUniqueId(), front: '', back: '', image: null, audio: null }]);
                }
            };

            return (
                <div className="min-h-screen bg-slate-50 py-8 px-2 sm:px-6 lg:px-8 font-sans text-slate-900 relative">
                
                {/* TOAST CONTAINER */}
                <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2 pointer-events-none">
                    {toasts.map(toast => (
                    <div key={toast.id} className={`flex items-center gap-2 px-4 py-3 rounded-lg shadow-lg text-sm font-medium animate-in slide-in-from-right fade-in duration-300 pointer-events-auto ${
                        toast.type === 'error' ? 'bg-red-50 text-red-700 border border-red-200' :
                        toast.type === 'success' ? 'bg-green-50 text-green-700 border border-green-200' :
                        'bg-blue-50 text-blue-700 border border-blue-200'
                    }`}>
                        {toast.type === 'error' ? <AlertCircle size={16}/> : 
                        toast.type === 'success' ? <CheckCircle size={16}/> : 
                        <AlertTriangle size={16}/>}
                        {toast.message}
                        <button onClick={() => removeToast(toast.id)} className="ml-2 opacity-50 hover:opacity-100"><X size={14}/></button>
                    </div>
                    ))}
                </div>

                {/* MODALS */}
                {previewImage && (
                    <div className="fixed inset-0 z-40 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4" onClick={() => setPreviewImage(null)}>
                    <div className="relative bg-white p-2 rounded-lg max-w-lg w-full" onClick={e => e.stopPropagation()}>
                        <img src={previewImage} alt="Preview" className="w-full h-auto rounded" />
                        <button onClick={() => setPreviewImage(null)} className="absolute -top-3 -right-3 bg-white text-slate-800 rounded-full p-2 shadow-lg hover:bg-red-50 hover:text-red-600"><X size={20}/></button>
                    </div>
                    </div>
                )}

                {activeContextId && (
                    <div className="fixed inset-0 z-40 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
                    <div className="bg-white rounded-xl shadow-xl w-full max-w-md p-6">
                        <h3 className="text-lg font-bold text-slate-800 mb-2 flex items-center gap-2"><MessageSquare size={20} className="text-indigo-600"/> Contexto Visual</h3>
                        <p className="text-sm text-slate-600 mb-4">Describe qu√© debe aparecer en la imagen.</p>
                        <textarea value={tempContext} onChange={(e) => setTempContext(e.target.value)} placeholder="Ej: Person running fast..." className="w-full h-24 p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 mb-4 text-sm"/>
                        <div className="flex justify-end gap-2">
                        <button onClick={() => setActiveContextId(null)} className="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg text-sm">Cancelar</button>
                        <button onClick={handleSaveContext} className="px-4 py-2 bg-indigo-600 text-white hover:bg-indigo-700 rounded-lg text-sm">Guardar</button>
                        </div>
                    </div>
                    </div>
                )}

                <div className="max-w-5xl mx-auto space-y-6">
                    <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4 bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                    <div>
                        <h1 className="text-2xl sm:text-3xl font-bold text-slate-800 tracking-tight flex items-center gap-2"><Languages className="text-indigo-600" /> Creador de Actividades</h1>
                        <p className="text-slate-500 mt-1 text-sm">Dise√±a lecciones biling√ºes ingl√©s-espa√±ol.</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => window.location.href='/'} className="px-3 py-2 text-sm font-medium text-slate-600 bg-slate-50 border border-slate-200 rounded-lg hover:bg-slate-100 transition-colors">Volver</button>
                        <button onClick={handleClearAll} className="px-3 py-2 text-sm font-medium text-slate-600 bg-slate-50 border border-slate-200 rounded-lg hover:bg-red-50 hover:text-red-600 transition-colors flex items-center gap-2"><Eraser size={16} /> Limpiar</button>
                        <button onClick={handleSave} className="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-sm hover:bg-indigo-700 active:scale-95 transition-all flex items-center gap-2"><Save size={18} /> Guardar</button>
                    </div>
                    </div>

                    <div className="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-xl p-4 sm:p-6 border border-indigo-100 shadow-sm">
                    <div className="flex flex-col sm:flex-row gap-3 items-center">
                        <div className="flex items-center gap-2 text-indigo-800 font-medium whitespace-nowrap"><Sparkles size={18} /> <span>IA M√°gica:</span></div>
                        <div className="flex w-full gap-2">
                        <input type="text" value={aiPrompt} onChange={(e) => setAiPrompt(e.target.value)} placeholder="Tema (ej: Frutas, Negocios...)" className="flex-1 px-4 py-2 border border-indigo-200 rounded-lg focus:ring-2 focus:ring-indigo-500 bg-white/80 text-sm" onKeyDown={(e) => e.key === 'Enter' && generateListWithAI()} />
                        <button onClick={generateListWithAI} disabled={isGeneratingList || !aiPrompt.trim()} className="px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 disabled:opacity-50 text-sm flex items-center gap-2">
                            {isGeneratingList ? <Loader2 className="animate-spin" size={16} /> : 'Generar'}
                        </button>
                        </div>
                    </div>
                    </div>

                    <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
                    <div className="p-6 border-b border-slate-100 bg-slate-50/50">
                        <label className="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">T√≠tulo de la Actividad</label>
                        <div className="relative">
                        <FileText className="absolute left-3 top-3.5 h-5 w-5 text-slate-400 pointer-events-none" />
                        <input type="text" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Ej: Unit 1 - Introduction" className="block w-full pl-10 pr-3 py-3 border border-slate-300 rounded-lg bg-white focus:ring-2 focus:ring-indigo-500 outline-none text-lg" />
                        </div>
                    </div>

                    <div className="p-4 bg-slate-50 border-b border-slate-200 flex flex-wrap gap-3 justify-between items-center">
                        <div className="flex items-center gap-2">
                        <span className="text-sm font-bold text-slate-700 bg-white px-3 py-1 rounded border border-slate-200 shadow-sm">{cards.length} {cards.length === 1 ? 'Tarjeta' : 'Tarjetas'}</span>
                        </div>
                        <div className="flex gap-2 w-full sm:w-auto">
                        <button onClick={() => generateBulk('image')} disabled={bulkProgress.type !== null} className="flex-1 sm:flex-none px-3 py-1.5 text-xs font-medium bg-white border border-slate-300 rounded hover:bg-indigo-50 hover:text-indigo-600 transition-colors flex items-center justify-center gap-1.5 disabled:opacity-50">
                            {bulkProgress.type === 'image' ? <Loader2 className="animate-spin" size={14}/> : <ImageIcon size={14} />} {bulkProgress.type === 'image' ? `Generando...` : 'Img para todas'}
                        </button>
                        <button onClick={() => generateBulk('audio')} disabled={bulkProgress.type !== null} className="flex-1 sm:flex-none px-3 py-1.5 text-xs font-medium bg-white border border-slate-300 rounded hover:bg-green-50 hover:text-green-600 transition-colors flex items-center justify-center gap-1.5 disabled:opacity-50">
                            {bulkProgress.type === 'audio' ? <Loader2 className="animate-spin" size={14}/> : <Volume2 size={14} />} {bulkProgress.type === 'audio' ? `Generando...` : 'Audio para todas'}
                        </button>
                        </div>
                    </div>

                    <div className="bg-slate-100 p-2 hidden sm:grid sm:grid-cols-12 gap-4 text-xs font-bold text-slate-500 uppercase tracking-wider items-center border-b border-slate-200">
                        <div className="sm:col-span-1 text-center">Orden</div>
                        <div className="sm:col-span-4">Front (Pregunta)</div>
                        <div className="sm:col-span-1 flex justify-center"><button onClick={handleSwapColumns} className="p-1 hover:bg-indigo-100 rounded text-indigo-600" title="Swap All"><ArrowRightLeft size={16} /></button></div>
                        <div className="sm:col-span-4">Back (Respuesta)</div>
                        <div className="sm:col-span-2 text-center">Acciones</div>
                    </div>

                    <div className="divide-y divide-slate-100">
                        {cards.map((card, index) => {
                        const isImgLoading = loadingCards[card.internalId] === 'image';
                        const isAudioLoading = loadingCards[card.internalId] === 'audio';
                        const hasContext = !!imageContexts[card.internalId];

                        return (
                            <div key={card.internalId} className="group p-4 hover:bg-slate-50 transition-colors">
                            <div className="flex flex-col sm:grid sm:grid-cols-12 gap-4 items-start">
                                <div className="hidden sm:flex sm:col-span-1 flex-col items-center justify-center gap-1 pt-2">
                                <button onClick={() => handleMoveCard(index, 'up')} disabled={index === 0} className="text-slate-300 hover:text-indigo-600 disabled:opacity-0"><ArrowUp size={16} /></button>
                                <span className="text-xs font-mono text-slate-400">{index + 1}</span>
                                <button onClick={() => handleMoveCard(index, 'down')} disabled={index === cards.length - 1} className="text-slate-300 hover:text-indigo-600 disabled:opacity-0"><ArrowDown size={16} /></button>
                                </div>
                                <div className="w-full sm:col-span-4 space-y-2">
                                <label className="sm:hidden text-xs font-bold text-slate-400">FRONT</label>
                                <input type="text" value={card.front} onChange={(e) => handleCardChange(card.internalId, 'front', e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none text-sm" placeholder="Texto" />
                                </div>
                                <div className="sm:col-span-1 flex justify-center pt-2 sm:pt-3 text-slate-300 sm:block hidden"><ArrowRightLeft size={14} className="mx-auto" /></div>
                                <div className="w-full sm:col-span-4 space-y-2">
                                    <label className="sm:hidden text-xs font-bold text-slate-400">BACK</label>
                                <input type="text" value={card.back} onChange={(e) => handleCardChange(card.internalId, 'back', e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none text-sm" placeholder="Traducci√≥n" />
                                </div>
                                <div className="w-full sm:col-span-2 flex sm:justify-center items-center gap-2 pt-2">
                                <button onClick={() => handleDuplicateCard(index)} title="Duplicar" className="p-1.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded"><Copy size={16} /></button>
                                <button onClick={() => handleInsertAfter(index)} title="Insertar Debajo" className="p-1.5 text-slate-400 hover:text-green-600 hover:bg-green-50 rounded"><Plus size={16} /></button>
                                <div className="h-4 w-px bg-slate-300 mx-1"></div>
                                <button onClick={() => handleDeleteCard(card.internalId)} title="Eliminar" className="p-1.5 text-slate-400 hover:text-red-600 hover:bg-red-50 rounded"><Trash2 size={16} /></button>
                                </div>
                            </div>

                            <div className="mt-3 pl-0 sm:pl-[8.33%] flex flex-wrap gap-4">
                                <div className={`flex items-center gap-2 p-1.5 rounded-lg border ${card.image ? 'border-indigo-100 bg-indigo-50/50' : 'border-dashed border-slate-200'}`}>
                                {card.image ? (
                                    <>
                                    <div className="relative group/img cursor-pointer" onClick={() => setPreviewImage(card.image)}>
                                        <img src={card.image} alt="mini" className="w-8 h-8 rounded object-cover border border-slate-200" />
                                        <div className="absolute inset-0 bg-black/20 rounded opacity-0 group-hover/img:opacity-100 flex items-center justify-center"><Eye size={12} className="text-white drop-shadow-md"/></div>
                                    </div>
                                    <div className="flex flex-col gap-1">
                                        <button onClick={() => generateImageForCard(card.internalId, card.front)} title="Regenerar" disabled={isImgLoading} className="text-[10px] text-indigo-600 hover:text-indigo-800 flex items-center gap-1">{isImgLoading ? <Loader2 size={10} className="animate-spin"/> : <RefreshCw size={10} />} Nuevo</button>
                                        <button onClick={() => handleRemoveMedia(card.internalId, 'image')} title="Eliminar" className="text-[10px] text-red-400 hover:text-red-600 flex items-center gap-1"><Trash2 size={10} /> Borrar</button>
                                    </div>
                                    </>
                                ) : (
                                    <button onClick={() => generateImageForCard(card.internalId, card.front)} disabled={isImgLoading || !card.front} className="flex items-center gap-1.5 text-xs text-slate-500 hover:text-indigo-600 px-2 py-1 disabled:opacity-50">
                                    {isImgLoading ? <Loader2 size={14} className="animate-spin"/> : <ImageIcon size={14} />} A√±adir Imagen
                                    </button>
                                )}
                                <button onClick={() => handleOpenContextModal(card.internalId, imageContexts[card.internalId])} title="Contexto imagen" className={`p-1.5 rounded-md transition-colors ${hasContext ? 'text-indigo-600 bg-indigo-50' : 'text-slate-400 hover:text-indigo-500 hover:bg-slate-100'}`}><Settings size={14} /></button>
                                </div>

                                <div className={`flex items-center gap-2 p-1.5 rounded-lg border ${card.audio ? 'border-green-100 bg-green-50/50' : 'border-dashed border-slate-200'}`}>
                                {card.audio ? (
                                    <>
                                    <button onClick={() => playAudio(card.audio)} className="w-8 h-8 flex items-center justify-center bg-white rounded-full border border-green-200 text-green-600 hover:scale-105 transition-transform shadow-sm"><Play size={14} className="fill-current ml-0.5" /></button>
                                    <div className="flex flex-col gap-1">
                                        <button onClick={() => generateAudioForCard(card.internalId, card.front)} title="Regenerar" disabled={isAudioLoading} className="text-[10px] text-green-700 hover:text-green-900 flex items-center gap-1">{isAudioLoading ? <Loader2 size={10} className="animate-spin"/> : <RefreshCw size={10} />} Nuevo</button>
                                        <button onClick={() => handleRemoveMedia(card.internalId, 'audio')} title="Eliminar" className="text-[10px] text-red-400 hover:text-red-600 flex items-center gap-1"><Trash2 size={10} /> Borrar</button>
                                    </div>
                                    </>
                                ) : (
                                    <button onClick={() => generateAudioForCard(card.internalId, card.front)} disabled={isAudioLoading || !card.front} className="flex items-center gap-1.5 text-xs text-slate-500 hover:text-green-600 px-2 py-1 disabled:opacity-50">
                                    {isAudioLoading ? <Loader2 size={14} className="animate-spin"/> : <Volume2 size={14} />} A√±adir Audio
                                    </button>
                                )}
                                </div>
                            </div>
                            </div>
                        );
                        })}
                    </div>
                    <div className="bg-slate-50 p-6 border-t border-slate-200">
                        <button onClick={handleAddCard} className="w-full py-3 border-2 border-dashed border-slate-300 rounded-lg text-slate-500 font-medium hover:border-indigo-500 hover:text-indigo-600 hover:bg-white transition-all flex items-center justify-center gap-2"><Plus size={18} /> A√±adir Fila al Final</button>
                    </div>
                    </div>
                </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<DashboardCreador />);
    </script>
</body>
</html>

