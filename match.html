<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Match Madness | Periplo</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            font-family: 'Varela Round', sans-serif;
            background-color: #f7f7f7;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            overflow: hidden;
        }

        /* Animaciones Jugosas */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
        }
        .animate-shake { animation: shake 0.4s ease-in-out; }

        @keyframes popOut {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(0.5); opacity: 0; }
        }
        .animate-pop-out { animation: popOut 0.25s forwards ease-in; }

        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop-in { animation: popIn 0.25s forwards ease-out; }

        @keyframes bounce-small {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce-small { animation: bounce-small 0.3s ease-out; }

        .btn-juicy { transition: transform 0.1s, background-color 0.2s, border-color 0.2s, color 0.2s; }
        .btn-juicy:active:not(:disabled) {
            transform: translateY(4px);
            border-bottom-width: 0px !important;
            margin-top: 4px;
        }
        
        .btn-wrapper {
            height: 4rem; /* Un poco mÃ¡s compactos para que quepan palabras largas */
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        /* Ocultar barra de scroll pero permitir deslizamiento si la palabra es larga */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- DATOS DEL JUEGO ---
        const ROUNDS = [
            { round: 1, pairsToWin: 15, timeSeconds: 60, title: "Calentamiento" },
            { round: 2, pairsToWin: 20, timeSeconds: 55, title: "Acelerando" },
            { round: 3, pairsToWin: 25, timeSeconds: 50, title: "Avanzado" },
            { round: 4, pairsToWin: 30, timeSeconds: 45, title: "Experto" },
            { round: 5, pairsToWin: 35, timeSeconds: 40, title: "Jefe Final" }
        ];

        // DICCIONARIO MAESTRO (Todos tus Packs y Special Words traducidos)
        const DICTIONARY = {
            "wake up": "despertar", "shower": "ducharse", "prepare": "preparar", "take": "tomar / llevar", "pick up": "recoger", "get": "conseguir", "start": "empezar", "work": "trabajar", "help": "ayudar", "send": "enviar", "attend": "asistir", "drive": "manejar", "fill up": "llenar", "review": "revisar", "sell": "vender", "upload": "subir", "download": "descargar", "leave": "salir / dejar", "make": "hacer (crear)", "do": "hacer (acciÃ³n)", "visit": "visitar", "walk": "caminar", "own": "poseer", "feed": "alimentar", "go": "ir", "see": "ver", "sleep": "dormir", "bring": "traer", "buy": "comprar", "lend": "prestar",
            "get in": "entrar", "get out": "salir", "agree": "acordar", "dance": "bailar", "arrive": "llegar", "practice": "practicar", "say": "decir", "tell": "contar / decir a", "speak": "hablar", "talk": "conversar", "rest": "descansar", "close": "cerrar", "write": "escribir", "read": "leer", "call": "llamar", "answer": "responder", "wait for": "esperar", "meet": "conocer / reunir", "check": "revisar", "find": "encontrar", "look for": "buscar", "eat": "comer", "drink": "beber", "cook": "cocinar", "clean": "limpiar", "wash": "lavar", "turn on": "encender", "turn off": "apagar", "use": "usar", "brush": "cepillar", "finish": "terminar", "know": "saber / conocer",
            "open": "abrir", "confirm": "confirmar", "continue": "continuar", "improve": "mejorar", "change": "cambiar", "break": "romper", "fix": "arreglar", "lose": "perder", "find out": "descubrir", "forget": "olvidar", "remember": "recordar", "watch": "mirar", "rain": "llover", "travel": "viajar", "teach": "enseÃ±ar", "stay": "quedarse", "move": "mudar / mover", "return": "regresar", "cancel": "cancelar", "steal": "robar", "fall": "caer", "hurt": "doler / herir", "worry": "preocupar", "trust": "confiar", "join": "unirse", "share": "compartir", "avoid": "evitar", "book": "reservar", "imagine": "imaginar", "come": "venir",
            "complain": "quejarse", "request": "solicitar", "explain": "explicar", "recommend": "recomendar", "let know": "hacer saber", "collect": "recolectar", "sign": "firmar", "promise": "prometer", "discuss": "discutir", "receive": "recibir", "deliver": "entregar", "order": "ordenar", "build": "construir", "repair": "reparar", "design": "diseÃ±ar", "manage": "gestionar", "organize": "organizar", "support": "apoyar", "follow": "seguir", "verify": "verificar", "celebrate": "celebrar", "sing": "cantar", "understand": "entender", "learn": "aprender", "listen": "escuchar", "laugh": "reÃ­r", "cry": "llorar", "borrow": "pedir prestado",
            "dream": "soÃ±ar", "complete": "completar", "report": "reportar", "solve": "resolver", "submit": "enviar", "suggest": "sugerir", "warn": "advertir", "wonder": "preguntarse", "choose": "elegir", "plan": "planear", "repeat": "repetir", "accomplish": "lograr", "relax": "relajarse", "compare": "comparar", "park": "estacionar", "plug": "enchufar", "carry": "cargar", "pay": "pagar", "switch": "intercambiar", "push": "empujar", "pull": "jalar", "show": "mostrar", "save": "ahorrar / salvar", "raise": "levantar / criar", "go down": "bajar", "increase": "aumentar", "reduce": "reducir", "hand": "entregar", "reach": "alcanzar",
            "think": "pensar", "believe": "creer", "feel": "sentir", "want": "querer", "need": "necesitar", "love": "amar", "hate": "odiar", "prefer": "preferir", "hope": "esperar", "enjoy": "disfrutar", "decide": "decidir", "allow": "permitir", "prevent": "prevenir", "protect": "proteger", "handle": "manejar", "perform": "realizar", "develop": "desarrollar", "grow": "crecer", "replace": "reemplazar", "throw": "lanzar", "catch": "atrapar", "sit": "sentarse", "stand": "ponerse de pie", "jump": "saltar", "run": "correr", "hide": "esconderse", "taste": "probar (sabor)", "smell": "oler", "touch": "tocar", "bite": "morder",
            "invite": "invitar", "accept": "aceptar", "refuse": "rechazar", "admit": "admitir", "deny": "negar", "offer": "ofrecer", "demand": "exigir", "advise": "aconsejar", "encourage": "animar", "mention": "mencionar", "describe": "describir", "identify": "identificar", "realize": "darse cuenta", "recognize": "reconocer", "suppose": "suponer", "guess": "adivinar", "measure": "medir", "weigh": "pesar", "fit": "quedar (talla)", "suit": "quedar bien", "match": "hacer juego", "fill": "llenar", "empty": "vaciar", "burn": "quemar", "freeze": "congelar", "melt": "derretir", "mix": "mezclar", "connect": "conectar", "succeed": "tener Ã©xito", "fail": "fracasar",
            "Hire": "Contratar", "Fire": "Despedir", "Earn": "Ganar (dinero)", "Spend": "Gastar", "Invest": "Invertir", "Owe": "Deber", "Promote": "Promover", "Retire": "Jubilarse", "Resign": "Renunciar", "Operate": "Operar", "Produce": "Producir", "Manufacture": "Fabricar", "Distribute": "Distribuir", "Store": "Almacenar", "Export": "Exportar", "Import": "Importar", "Inspect": "Inspeccionar", "Negotiate": "Negociar", "Persuade": "Persuadir", "Convince": "Convencer", "Represent": "Representar", "Regulate": "Regular", "Govern": "Gobernar", "Vote": "Votar", "Resolve": "Resolver", "Cooperate": "Cooperar", "Compete": "Competir", "Win": "Ganar", "Beat": "Vencer", "Gain": "Obtener",
            "Cure": "Curar", "Heal": "Sanar", "Suffer": "Sufrir", "Bleed": "Sangrar", "Recover": "Recuperarse", "Examine": "Examinar", "Diagnose": "Diagnosticar", "Prescribe": "Recetar", "Treat": "Tratar", "Board": "Abordar", "Land": "Aterrizar", "Take off": "Despegar", "Reserve": "Reservar", "Accommodate": "Acomodar", "Check in": "Registrarse", "Check out": "Salir (hotel)", "Explore": "Explorar", "Guide": "Guiar", "Wander": "Deambular", "Escape": "Escapar", "Survive": "Sobrevivir", "Attack": "Atacar", "Defend": "Defender", "Fight": "Pelear", "Greet": "Saludar", "Introduce": "Presentar", "Appreciate": "Apreciar", "Forgive": "Perdonar", "Criticize": "Criticar", "Praise": "Elogiar",
            
            // KEYWORDS
            "What": "QuÃ©", "Where": "DÃ³nde", "When": "CuÃ¡ndo / Cuando", "Who": "QuiÃ©n", "Why": "Por quÃ©", "Which": "CuÃ¡l", "How": "CÃ³mo", "Whose": "De quiÃ©n", "Whom": "A quiÃ©n", "What time": "A quÃ© hora", "How often": "Con quÃ© frecuencia", "How much": "CuÃ¡nto", "How many": "CuÃ¡ntos", "How long": "CuÃ¡nto tiempo",
            "For": "Por / Para", "And": "Y", "Nor": "Ni", "But": "Pero", "Or": "O", "Yet": "Sin embargo", "So": "AsÃ­ que",
            "While": "Mientras", "Before": "Antes", "After": "DespuÃ©s", "Until": "Hasta", "Since": "Desde", "As soon as": "Tan pronto como", "Because": "Porque", "As": "Como", "If": "Si", "Unless": "A menos que", "Even if": "Incluso si", "Although": "Aunque", "Though": "Aunque (corto)", "Even though": "A pesar de que", "Whereas": "Mientras que",
            "in": "en (dentro)", "on": "en (sobre)", "at": "en (punto)", "about": "acerca de", "against": "contra", "according to": "segÃºn", "during": "durante", "so that": "para que", "instead of": "en lugar de", "then": "entonces", "thatâ€™s why": "por eso",
            "between": "entre dos", "among": "entre varios", "next to": "al lado de", "behind": "detrÃ¡s", "in front of": "enfrente", "close to": "cerca de", "by": "por / junto a", "under": "debajo", "below": "abajo", "underneath": "por debajo", "over": "por encima", "above": "arriba", "across from": "cruzando", "opposite": "opuesto", "ahead": "adelante", "within": "dentro de",
            "Plenty": "Suficiente", "A lot": "Mucho", "Many": "Muchos", "Most": "La mayorÃ­a", "Several": "Varios", "Enough": "Suficiente (cantidad)", "Half": "Mitad", "Some": "Algunos", "A little": "Un poco (incontable)", "A few": "Unos pocos", "A bit": "Un poco", "A couple": "Un par", "Any": "Cualquier", "None": "Ninguno", "The whole": "Todo el",
            "always": "siempre", "usually": "usualmente", "often": "a menudo", "sometimes": "a veces", "hardly ever": "casi nunca", "never": "nunca", "now": "ahora", "today": "hoy", "yesterday": "ayer", "tomorrow": "maÃ±ana", "soon": "pronto", "later": "luego", "tonight": "esta noche",
            "my": "mi", "your": "tu / su", "his": "su (Ã©l)", "her": "su (ella)", "its": "su (eso)", "our": "nuestro", "their": "su (ellos)",
            "me": "a mÃ­", "you": "a ti", "him": "a Ã©l", "us": "a nosotros", "them": "a ellos"
        };

        // Generar el pool dinÃ¡micamente
        const INITIAL_WORD_POOL = Object.entries(DICTIONARY).map(([en, es], index) => ({
            id: index + 1,
            en: en,
            es: es
        }));

        const shuffleArray = (array) => {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        // --- COMPONENTES DE INTERFAZ ---
        const WordButton = ({ text, status, onClick }) => {
            let baseClasses = "btn-juicy w-full h-full rounded-2xl border-2 font-bold text-sm sm:text-base md:text-lg flex items-center justify-center cursor-pointer select-none overflow-x-auto no-scrollbar whitespace-nowrap px-2 ";
            let colorClasses = "";
            let animClasses = "";

            if (status === 'idle' || status === 'entering') {
                colorClasses = "bg-white border-b-4 border-slate-200 text-slate-700 hover:bg-slate-50";
                if (status === 'entering') animClasses = "animate-pop-in";
            } else if (status === 'selected') {
                colorClasses = "bg-sky-50 border-sky-400 border-b-4 text-sky-600";
            } else if (status === 'correct') {
                colorClasses = "bg-green-100 border-green-400 text-green-600 border-b-4";
                animClasses = "animate-pop-out";
            } else if (status === 'wrong') {
                colorClasses = "bg-red-100 border-red-400 text-red-600 border-b-4";
                animClasses = "animate-shake";
            }

            return (
                <div className="btn-wrapper">
                    <button 
                        className={`${baseClasses} ${colorClasses} ${animClasses}`}
                        onClick={onClick}
                        disabled={status === 'correct' || status === 'wrong'}
                    >
                        {text}
                    </button>
                </div>
            );
        };

        // --- COMPONENTE PRINCIPAL ---
        const App = () => {
            const [gameState, setGameState] = useState('menu'); 
            const [currentRoundIdx, setCurrentRoundIdx] = useState(0);
            
            const [timeLeft, setTimeLeft] = useState(0);
            const [score, setScore] = useState(0);
            const [leftCol, setLeftCol] = useState([]);
            const [rightCol, setRightCol] = useState([]);
            
            const [selectedLeft, setSelectedLeft] = useState(null);
            const [selectedRight, setSelectedRight] = useState(null);

            // Estado del Bitmoji (idle, happy, wrong)
            const [bitmojiState, setBitmojiState] = useState('idle');

            const poolRef = useRef([]);
            const poolIndexRef = useRef(0);
            const scoreRef = useRef(0);
            const currentRoundData = ROUNDS[currentRoundIdx];

            const startRound = (roundIdx = currentRoundIdx) => {
                const roundData = ROUNDS[roundIdx];
                const shuffledPool = shuffleArray(INITIAL_WORD_POOL);
                poolRef.current = shuffledPool;
                
                const initialWords = shuffledPool.slice(0, 5);
                poolIndexRef.current = 5; 

                const rightShuffled = shuffleArray([...initialWords]);

                setLeftCol(initialWords.map(w => ({ id: w.id, text: w.es, status: 'idle', animKey: Date.now() + Math.random() })));
                setRightCol(rightShuffled.map(w => ({ id: w.id, text: w.en, status: 'idle', animKey: Date.now() + Math.random() })));
                
                setScore(0);
                scoreRef.current = 0;
                setTimeLeft(roundData.timeSeconds);
                setSelectedLeft(null);
                setSelectedRight(null);
                setCurrentRoundIdx(roundIdx);
                setBitmojiState('idle');
                setGameState('playing');
            };

            const resetGame = () => {
                setCurrentRoundIdx(0);
                setGameState('menu');
            };

            useEffect(() => {
                let timer;
                if (gameState === 'playing' && timeLeft > 0) {
                    timer = setInterval(() => {
                        setTimeLeft(prev => {
                            if (prev <= 0.1) {
                                clearInterval(timer);
                                if (scoreRef.current < ROUNDS[currentRoundIdx].pairsToWin) setGameState('game_over');
                                return 0;
                            }
                            return prev - 0.1;
                        });
                    }, 100);
                }
                return () => clearInterval(timer);
            }, [gameState, currentRoundIdx]);

            useEffect(() => {
                if (gameState === 'playing' && score >= currentRoundData.pairsToWin) {
                    if (currentRoundIdx === ROUNDS.length - 1) setGameState('game_won');
                    else setGameState('round_won');
                }
            }, [score, gameState, currentRoundIdx, currentRoundData]);

            const getNextWord = useCallback(() => {
                const pool = poolRef.current;
                const word = pool[poolIndexRef.current % pool.length]; 
                poolIndexRef.current += 1;
                return word;
            }, []);

            const processMatch = (leftIndex, rightIndex) => {
                const leftItem = leftCol[leftIndex];
                const rightItem = rightCol[rightIndex];
                const isMatch = leftItem.id === rightItem.id;

                if (isMatch) {
                    setLeftCol(prev => prev.map((item, i) => i === leftIndex ? { ...item, status: 'correct' } : item));
                    setRightCol(prev => prev.map((item, i) => i === rightIndex ? { ...item, status: 'correct' } : item));
                    
                    const newScore = scoreRef.current + 1;
                    scoreRef.current = newScore;
                    setScore(newScore);

                    // ReacciÃ³n Bitmoji Acierto
                    setBitmojiState('happy');

                    setTimeout(() => {
                        if (scoreRef.current <= ROUNDS[currentRoundIdx].pairsToWin) {
                            const newWord = getNextWord();
                            const animId = Date.now() + Math.random();
                            
                            setLeftCol(prev => {
                                const next = [...prev];
                                next[leftIndex] = { id: newWord.id, text: newWord.es, status: 'entering', animKey: animId };
                                return next;
                            });
                            setRightCol(prev => {
                                const next = [...prev];
                                next[rightIndex] = { id: newWord.id, text: newWord.en, status: 'entering', animKey: animId + 1 };
                                return next;
                            });

                            setTimeout(() => {
                                setLeftCol(p => p.map((item, i) => i === leftIndex ? { ...item, status: 'idle' } : item));
                                setRightCol(p => p.map((item, i) => i === rightIndex ? { ...item, status: 'idle' } : item));
                                // Devolver Bitmoji a normal si no ha habido otro error intermedio
                                setBitmojiState(prev => prev === 'happy' ? 'idle' : prev);
                            }, 250);
                        }
                    }, 250);

                } else {
                    setLeftCol(prev => prev.map((item, i) => i === leftIndex ? { ...item, status: 'wrong' } : item));
                    setRightCol(prev => prev.map((item, i) => i === rightIndex ? { ...item, status: 'wrong' } : item));

                    // ReacciÃ³n Bitmoji Error
                    setBitmojiState('wrong');

                    setTimeout(() => {
                        setLeftCol(prev => prev.map((item, i) => i === leftIndex ? { ...item, status: 'idle' } : item));
                        setRightCol(prev => prev.map((item, i) => i === rightIndex ? { ...item, status: 'idle' } : item));
                        setBitmojiState(prev => prev === 'wrong' ? 'idle' : prev);
                    }, 400); 
                }
            };

            const handleWordClick = (side, index) => {
                const column = side === 'left' ? leftCol : rightCol;
                if (column[index].status === 'correct' || column[index].status === 'wrong') return;

                if (side === 'left') {
                    if (selectedLeft === index) {
                        setSelectedLeft(null);
                        setLeftCol(prev => prev.map((item, i) => i === index ? { ...item, status: 'idle' } : item));
                        return;
                    }
                    setLeftCol(prev => prev.map((item, i) => {
                        if (i === index) return { ...item, status: 'selected' };
                        if (i === selectedLeft) return { ...item, status: 'idle' };
                        return item;
                    }));
                    setSelectedLeft(index);
                    if (selectedRight !== null) {
                        processMatch(index, selectedRight);
                        setSelectedLeft(null);
                        setSelectedRight(null);
                    }
                } else {
                    if (selectedRight === index) {
                        setSelectedRight(null);
                        setRightCol(prev => prev.map((item, i) => i === index ? { ...item, status: 'idle' } : item));
                        return;
                    }
                    setRightCol(prev => prev.map((item, i) => {
                        if (i === index) return { ...item, status: 'selected' };
                        if (i === selectedRight) return { ...item, status: 'idle' };
                        return item;
                    }));
                    setSelectedRight(index);
                    if (selectedLeft !== null) {
                        processMatch(selectedLeft, index);
                        setSelectedLeft(null);
                        setSelectedRight(null);
                    }
                }
            };

            return (
                <div className="min-h-screen flex flex-col items-center bg-slate-100 px-4 py-6 md:py-10 text-slate-800">
                    <div className="w-full max-w-4xl mx-auto flex-1 flex flex-col">
                        
                        {gameState === 'menu' && (
                            <div className="flex-1 flex flex-col items-center justify-center text-center animate-pop-in max-w-md mx-auto">
                                <div className="mb-8 p-6 bg-white rounded-3xl shadow-sm border-2 border-b-[6px] border-slate-200">
                                    <h1 className="text-4xl font-extrabold text-sky-500 mb-2">Match<br/>Madness</h1>
                                    <p className="text-slate-500 font-medium">Empareja palabras a la velocidad de la luz.</p>
                                </div>
                                <div className="space-y-4 w-full">
                                    <button 
                                        className="w-full btn-juicy bg-green-400 text-white border-2 border-b-[6px] border-green-600 rounded-2xl py-4 text-xl font-bold uppercase tracking-widest"
                                        onClick={() => startRound(0)}
                                    >
                                        Jugar
                                    </button>
                                </div>
                            </div>
                        )}

                        {gameState === 'playing' && (
                            <div className="flex-1 flex flex-col w-full relative">
                                {/* Header / HUD */}
                                <div className="mb-6 max-w-xl mx-auto w-full">
                                    <div className="flex justify-between items-center mb-3">
                                        <div className="font-bold text-slate-400 uppercase tracking-widest text-sm">
                                            Ronda {currentRoundIdx + 1}
                                        </div>
                                        <div className="font-bold text-sky-500 text-xl">
                                            {score} / {currentRoundData.pairsToWin}
                                        </div>
                                    </div>
                                    <div className="h-4 w-full bg-slate-200 rounded-full overflow-hidden relative">
                                        <div 
                                            className={`absolute top-0 left-0 h-full transition-all duration-100 ease-linear rounded-full ${
                                                timeLeft < 10 ? 'bg-red-400' : 'bg-orange-400'
                                            }`}
                                            style={{ width: `${(timeLeft / currentRoundData.timeSeconds) * 100}%` }}
                                        />
                                    </div>
                                </div>

                                {/* Zona de Juego con 3 Columnas (EspaÃ±ol - Bitmoji - InglÃ©s) */}
                                <div className="flex-1 grid grid-cols-[1fr_60px_1fr] md:grid-cols-[1fr_120px_1fr] gap-2 md:gap-6 mt-2 relative items-center">
                                    
                                    {/* Columna Izquierda (EspaÃ±ol) */}
                                    <div className="flex flex-col gap-3">
                                        {leftCol.map((item, index) => (
                                            <WordButton 
                                                key={item.animKey}
                                                text={item.text} 
                                                status={item.status}
                                                onClick={() => handleWordClick('left', index)}
                                            />
                                        ))}
                                    </div>
                                    
                                    {/* Columna Central (Bitmoji Reacciones) */}
                                    <div className="flex flex-col justify-center items-center h-full">
                                        {bitmojiState === 'idle' && (
                                            <img src="image_c9055d.jpg" alt="Thinking" className="w-16 md:w-32 rounded-full transition-transform duration-300 drop-shadow-md" />
                                        )}
                                        {bitmojiState === 'happy' && (
                                            <img src="image_c9025d.png" alt="Correct!" className="w-20 md:w-40 animate-bounce-small drop-shadow-lg z-10" />
                                        )}
                                        {bitmojiState === 'wrong' && (
                                            <img src="image_c9055d.jpg" alt="Wrong" className="w-16 md:w-32 rounded-full animate-shake drop-shadow-md border-4 border-red-400" style={{ filter: 'grayscale(50%) sepia(100%) hue-rotate(300deg)' }} />
                                        )}
                                    </div>
                                    
                                    {/* Columna Derecha (InglÃ©s) */}
                                    <div className="flex flex-col gap-3">
                                        {rightCol.map((item, index) => (
                                            <WordButton 
                                                key={item.animKey}
                                                text={item.text} 
                                                status={item.status}
                                                onClick={() => handleWordClick('right', index)}
                                            />
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}

                        {(gameState === 'round_won' || gameState === 'game_won' || gameState === 'game_over') && (
                            <div className="flex-1 flex flex-col items-center justify-center text-center animate-pop-in z-10 max-w-md mx-auto w-full">
                                <div className={`p-8 rounded-3xl w-full border-2 border-b-[6px] mb-8 ${
                                    gameState === 'game_over' ? 'bg-white border-slate-200' : 
                                    gameState === 'game_won' ? 'bg-yellow-100 border-yellow-300' : 
                                    'bg-green-50 border-green-200'
                                }`}>
                                    
                                    {gameState === 'round_won' && (
                                        <>
                                            <h2 className="text-3xl font-extrabold text-green-500 mb-2">Â¡Ronda {currentRoundIdx + 1} Superada!</h2>
                                            <p className="text-green-700 font-medium">Reflejos impresionantes.</p>
                                        </>
                                    )}

                                    {gameState === 'game_won' && (
                                        <>
                                            <h2 className="text-4xl font-extrabold text-yellow-500 mb-2">Â¡VICTORIA TOTAL!</h2>
                                            <p className="text-yellow-700 font-medium mb-4">Has dominado la locura de las palabras.</p>
                                            <div className="text-6xl">ðŸ‘‘</div>
                                        </>
                                    )}

                                    {gameState === 'game_over' && (
                                        <>
                                            <h2 className="text-3xl font-extrabold text-red-500 mb-2">Se acabÃ³ el tiempo</h2>
                                            <p className="text-slate-500 font-medium">Lograste {score} de {currentRoundData.pairsToWin} pares.</p>
                                        </>
                                    )}
                                </div>

                                <div className="w-full space-y-4">
                                    {gameState === 'round_won' && (
                                        <button 
                                            className="w-full btn-juicy bg-sky-400 text-white border-2 border-b-[6px] border-sky-600 rounded-2xl py-4 text-xl font-bold uppercase tracking-widest"
                                            onClick={() => startRound(currentRoundIdx + 1)}
                                        >
                                            Siguiente Ronda
                                        </button>
                                    )}
                                    
                                    {(gameState === 'game_over' || gameState === 'game_won') && (
                                        <button 
                                            className="w-full btn-juicy bg-sky-400 text-white border-2 border-b-[6px] border-sky-600 rounded-2xl py-4 text-xl font-bold uppercase tracking-widest"
                                            onClick={resetGame}
                                        >
                                            Volver al MenÃº
                                        </button>
                                    )}
                                </div>
                            </div>
                        )}

                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>