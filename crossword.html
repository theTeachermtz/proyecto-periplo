<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Periplo - Crucigrama</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>游빌</text></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700;800&display=swap'); 
        body { font-family: 'Plus Jakarta Sans', sans-serif; background-color: #f0f4f8; }
        
        /* Grid Styles */
        .cw-cell { transition: all 0.2s; }
        .cw-cell:focus { outline: none; background-color: #e0e7ff; border-color: #6366f1; }
        .cw-cell.active-word { background-color: #eff6ff; }
        .cw-cell.correct { background-color: #dcfce7; color: #166534; border-color: #86efac; }
        
        @keyframes confetti { 0% { transform: translate(-50%, -50%) rotate(0deg); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) rotate(720deg); opacity: 0; } }
        .animate-confetti { animation: confetti 1s ease-out forwards; }
        .animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { initializeApp } from 'firebase/app';
        import { getFirestore, doc, getDoc } from 'firebase/firestore';
        import { ArrowLeft, RefreshCw, Check, X, Trophy, LogOut, Loader2, Pause, List, RotateCcw, ChevronRight } from 'lucide-react';

        const firebaseConfig = {
            apiKey: "AIzaSyD4d-Kx1jQbgrKIdeOftv7BM729m7MIGPo",
            authDomain: "proyecto-periplo.firebaseapp.com",
            projectId: "proyecto-periplo",
            storageBucket: "proyecto-periplo.firebasestorage.app",
            messagingSenderId: "236795998392",
            appId: "1:236795998392:web:0da24b4f018611b55c844d"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- MOTOR DE CRUCIGRAMA ROBUSTO (v2) ---
        class CrosswordGenerator {
            constructor(width = 20, height = 20) { // AUMENTADO A 20x20
                this.width = width;
                this.height = height;
                this.grid = Array(height).fill(null).map(() => Array(width).fill(null));
                this.placedWords = [];
            }

            generate(wordList) {
                const sortedWords = [...wordList]
                    .filter(w => w.front && w.front.length > 1 && w.front.length < this.width) // Filtrar palabras demasiado largas
                    .map(w => ({ ...w, answer: w.front.toUpperCase().replace(/[^A-Z]/g, ''), clue: w.back }))
                    .sort((a, b) => b.answer.length - a.answer.length);

                if (sortedWords.length === 0) return null;

                // Colocar primera palabra (Validando l칤mites)
                const first = sortedWords[0];
                const startX = Math.floor((this.width - first.answer.length) / 2);
                const startY = Math.floor(this.height / 2);
                
                // Validaci칩n extra para la primera palabra
                if (this.canPlace(first.answer, startY, startX, 'across')) {
                    this.placeWord(first, startY, startX, 'across');
                } else {
                    return null; // Si la primera no cabe, abortar misi칩n
                }

                // Intentar colocar las dem치s
                for (let i = 1; i < sortedWords.length; i++) {
                    this.tryPlaceWord(sortedWords[i]);
                }
                
                return this.exportData();
            }

            tryPlaceWord(wordObj) {
                const { answer } = wordObj;
                const bestPositions = [];

                for (const placed of this.placedWords) {
                    for (let i = 0; i < answer.length; i++) {
                        for (let j = 0; j < placed.answer.length; j++) {
                            if (answer[i] === placed.answer[j]) {
                                const newDir = placed.direction === 'across' ? 'down' : 'across';
                                let r, c;
                                // Ajuste de coordenadas seg칰n direcci칩n
                                if (newDir === 'down') { 
                                    r = placed.row - i; 
                                    c = placed.col + j; 
                                } else { 
                                    r = placed.row + j; 
                                    c = placed.col - i; 
                                }

                                if (this.canPlace(answer, r, c, newDir)) {
                                    bestPositions.push({ r, c, dir: newDir });
                                }
                            }
                        }
                    }
                }
                
                if (bestPositions.length > 0) {
                    // Elegir la posici칩n m치s central o aleatoria para variedad
                    const pos = bestPositions[0];
                    this.placeWord(wordObj, pos.r, pos.c, pos.dir);
                    return true;
                }
                return false;
            }

            canPlace(word, row, col, direction) {
                // 1. Validar l칤mites absolutos del tablero
                if (row < 0 || col < 0) return false;
                if (direction === 'across') {
                    if (col + word.length > this.width) return false;
                } else {
                    if (row + word.length > this.height) return false;
                }

                // 2. Validar colisiones
                if (direction === 'across') {
                    // Verificar celda anterior (no pegar palabras)
                    if (col > 0 && this.grid[row][col - 1] !== null) return false;
                    // Verificar celda posterior
                    if (col + word.length < this.width && this.grid[row][col + word.length] !== null) return false;

                    for (let i = 0; i < word.length; i++) {
                        const cell = this.grid[row][col + i];
                        // Si hay letra, debe coincidir (cruce)
                        if (cell !== null && cell !== word[i]) return false;
                        
                        // Si est치 vac칤a, verificar vecinos (no pegar lateralmente)
                        if (cell === null) {
                            if (row > 0 && this.grid[row - 1][col + i] !== null) return false;
                            if (row + 1 < this.height && this.grid[row + 1][col + i] !== null) return false;
                        }
                    }
                } else { // Down
                    if (row > 0 && this.grid[row - 1][col] !== null) return false;
                    if (row + word.length < this.height && this.grid[row + word.length][col] !== null) return false;

                    for (let i = 0; i < word.length; i++) {
                        const cell = this.grid[row + i][col];
                        if (cell !== null && cell !== word[i]) return false;
                        if (cell === null) {
                            if (col > 0 && this.grid[row + i][col - 1] !== null) return false;
                            if (col + 1 < this.width && this.grid[row + i][col + 1] !== null) return false;
                        }
                    }
                }
                return true;
            }

            placeWord(wordObj, row, col, direction) {
                const { answer } = wordObj;
                this.placedWords.push({ ...wordObj, row, col, direction });
                for (let i = 0; i < answer.length; i++) {
                    if (direction === 'across') this.grid[row][col + i] = answer[i];
                    else this.grid[row + i][col] = answer[i];
                }
            }

            exportData() {
                // Ordenar para asignar n칰meros: 1. Arriba->Abajo, 2. Izquierda->Derecha
                this.placedWords.sort((a, b) => (a.row === b.row ? a.col - b.col : a.row - b.row));
                
                let currentNum = 1;
                const cells = {};
                
                // L칩gica para asignar n칰meros correctamente (compartidos si empiezan en la misma celda)
                this.placedWords.forEach((word) => {
                    const key = `${word.row}-${word.col}`;
                    if (!cells[key]) cells[key] = currentNum++;
                    word.number = cells[key];
                });
                
                return { width: this.width, height: this.height, words: this.placedWords, gridStructure: this.grid };
            }
        }

        // --- UI ---
        const Confetti = () => {
            const colors = ['#6366f1', '#ec4899', '#10b981', '#f59e0b'];
            return (<div className="absolute inset-0 pointer-events-none z-50 overflow-hidden flex justify-center">{[...Array(30)].map((_, i) => (<div key={i} className="absolute w-2 h-2 rounded-full animate-confetti" style={{backgroundColor: colors[i % colors.length], left: '50%', top: '50%', '--tx': `${(Math.random()-0.5)*600}px`, '--ty': `${(Math.random()-1)*600}px`, animationDelay: `${Math.random()*0.3}s`}} />))}</div>);
        };

        const CrosswordGame = () => {
            const [loading, setLoading] = useState(true);
            const [gameData, setGameData] = useState(null);
            const [gridValues, setGridValues] = useState({});
            const [selectedCell, setSelectedCell] = useState(null);
            const [direction, setDirection] = useState('across');
            const [status, setStatus] = useState('playing');
            const [gameId, setGameId] = useState(null);
            const inputRefs = useRef({});

            useEffect(() => {
                const init = async () => {
                    const params = new URLSearchParams(window.location.search);
                    const id = params.get('id');
                    setGameId(id);
                    if (!id) return alert("Falta ID");
                    try {
                        const docRef = doc(db, 'artifacts/periplo-app-v1/users/teacher_builder_001/quizzes', id);
                        const snap = await getDoc(docRef);
                        if (snap.exists()) {
                            const data = snap.data();
                            const generator = new CrosswordGenerator(20, 20); // Grid m치s grande
                            const layout = generator.generate(data.questions);
                            
                            if (layout && layout.words.length > 0) {
                                setGameData(layout);
                                setSelectedCell({ r: layout.words[0].row, c: layout.words[0].col });
                            } else {
                                alert("No se pudo generar el crucigrama. Las palabras son muy dif칤ciles de cruzar o muy pocas.");
                            }
                        }
                    } catch (e) { console.error(e); } finally { setLoading(false); }
                };
                init();
            }, []);

            useEffect(() => {
                if (selectedCell && inputRefs.current[`${selectedCell.r}-${selectedCell.c}`]) {
                    inputRefs.current[`${selectedCell.r}-${selectedCell.c}`].focus();
                }
            }, [selectedCell]);

            const activeWord = useMemo(() => {
                if (!gameData || !selectedCell) return null;
                return gameData.words.find(w => {
                    const isAcross = w.direction === 'across' && direction === 'across';
                    const isDown = w.direction === 'down' && direction === 'down';
                    if (isAcross) return w.row === selectedCell.r && selectedCell.c >= w.col && selectedCell.c < w.col + w.answer.length;
                    if (isDown) return w.col === selectedCell.c && selectedCell.r >= w.row && selectedCell.r < w.row + w.answer.length;
                    return false;
                });
            }, [gameData, selectedCell, direction]);

            useEffect(() => {
                if (!gameData) return;
                const isComplete = gameData.words.every(w => {
                    for (let i = 0; i < w.answer.length; i++) {
                        const r = w.direction === 'across' ? w.row : w.row + i;
                        const c = w.direction === 'across' ? w.col + i : w.col;
                        if (gridValues[`${r}-${c}`] !== w.answer[i]) return false;
                    }
                    return true;
                });
                if (isComplete && status !== 'victory') setStatus('victory');
            }, [gridValues]);

            const handleCellClick = (r, c) => {
                if (selectedCell?.r === r && selectedCell?.c === c) {
                    setDirection(prev => prev === 'across' ? 'down' : 'across');
                } else {
                    setSelectedCell({ r, c });
                }
            };

            const handleInput = (val, r, c) => {
                const char = val.slice(-1).toUpperCase();
                setGridValues(p => ({ ...p, [`${r}-${c}`]: char }));
                if (char) {
                    const dr = direction === 'across' ? 0 : 1;
                    const dc = direction === 'across' ? 1 : 0;
                    if (gameData.gridStructure[r+dr]?.[c+dc] !== null) {
                        setSelectedCell({ r: r + dr, c: c + dc });
                    }
                }
            };

            const handleKeyDown = (e, r, c) => {
                if (e.key === 'Backspace' && !gridValues[`${r}-${c}`]) {
                    const dr = direction === 'across' ? 0 : 1;
                    const dc = direction === 'across' ? 1 : 0;
                    if (gameData.gridStructure[r-dr]?.[c-dc] !== null) {
                        setSelectedCell({ r: r - dr, c: c - dc });
                    }
                }
            };

            const handleExit = () => { window.location.href = `activity.html?id=${gameId}`; };

            if (loading) return <div className="h-screen flex items-center justify-center text-indigo-500"><Loader2 className="animate-spin" size={40}/></div>;
            if (!gameData) return <div className="h-screen flex items-center justify-center text-slate-400 font-bold">No se pudo generar el juego.</div>;

            return (
                <div className="h-screen flex flex-col bg-slate-100 overflow-hidden font-sans text-slate-800">
                    <div className="h-16 bg-white shadow-sm flex items-center justify-between px-6 z-10 shrink-0">
                        <div className="font-black text-slate-400 text-xs tracking-widest uppercase">CRUCIGRAMA</div>
                        <button onClick={handleExit} className="flex gap-2 items-center text-xs font-bold text-slate-400 hover:text-rose-500 uppercase">Salir <LogOut size={16}/></button>
                    </div>

                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden max-w-6xl mx-auto w-full">
                        <div className="flex-1 flex items-center justify-center p-4 overflow-auto bg-slate-100/50">
                            <div className="grid gap-px bg-slate-300 border border-slate-300 p-1 rounded-lg shadow-xl" style={{ gridTemplateColumns: `repeat(${gameData.width}, minmax(0, 1fr))`, width: '100%', maxWidth: '600px', aspectRatio: '1/1' }}>
                                {Array.from({ length: gameData.height }).map((_, r) => (
                                    Array.from({ length: gameData.width }).map((_, c) => {
                                        const cellData = gameData.gridStructure[r][c];
                                        if (cellData === null) return <div key={`${r}-${c}`} className="bg-slate-900"></div>;
                                        
                                        const wordStart = gameData.words.find(w => w.row === r && w.col === c);
                                        const isSelected = selectedCell?.r === r && selectedCell?.c === c;
                                        const isActiveWord = activeWord && ((activeWord.direction === 'across' && r === activeWord.row && c >= activeWord.col && c < activeWord.col + activeWord.answer.length) || (activeWord.direction === 'down' && c === activeWord.col && r >= activeWord.row && r < activeWord.row + activeWord.answer.length));

                                        return (
                                            <div key={`${r}-${c}`} className={`relative bg-white flex items-center justify-center ${isSelected ? 'bg-yellow-100' : isActiveWord ? 'bg-indigo-50' : ''}`} onClick={() => handleCellClick(r, c)}>
                                                {wordStart && <span className="absolute top-0.5 left-0.5 text-[8px] font-bold text-slate-500 leading-none">{wordStart.number}</span>}
                                                <input ref={el => inputRefs.current[`${r}-${c}`] = el} type="text" maxLength="1" value={gridValues[`${r}-${c}`] || ''} onChange={e => handleInput(e.target.value, r, c)} onKeyDown={e => handleKeyDown(e, r, c)} className="w-full h-full text-center font-bold uppercase bg-transparent outline-none text-slate-800 text-lg md:text-xl"/>
                                            </div>
                                        );
                                    })
                                ))}
                            </div>
                        </div>

                        <div className="h-1/3 md:h-full md:w-80 bg-white border-l border-slate-200 flex flex-col shadow-xl z-20">
                            <div className="p-4 border-b bg-indigo-50">
                                <span className="text-[10px] font-bold text-indigo-400 uppercase tracking-widest mb-1 block">PISTA ACTUAL</span>
                                {activeWord ? (
                                    <div className="flex items-start gap-3">
                                        <div className="w-8 h-8 bg-indigo-600 rounded-full flex items-center justify-center text-white font-bold shrink-0">{activeWord.number}</div>
                                        <div>
                                            <p className="font-bold text-slate-800 text-lg leading-tight">{activeWord.clue}</p>
                                            {activeWord.image && <div className="mt-2 h-20 rounded-lg overflow-hidden border border-indigo-100"><img src={activeWord.image} className="h-full w-full object-contain bg-white"/></div>}
                                        </div>
                                    </div>
                                ) : <p className="text-slate-400 italic text-sm">Selecciona una celda...</p>}
                            </div>
                            <div className="flex-1 overflow-y-auto p-4 space-y-4">
                                <div>
                                    <h4 className="text-xs font-black text-slate-400 uppercase mb-2">Todas las Pistas</h4>
                                    <div className="space-y-2">
                                        {gameData.words.map((w, i) => (
                                            <button key={i} onClick={() => { setSelectedCell({r: w.row, c: w.col}); setDirection(w.direction); }} className={`w-full text-left p-3 rounded-xl border transition-all flex gap-3 ${activeWord === w ? 'bg-indigo-600 text-white border-indigo-600 shadow-md transform scale-105' : 'bg-slate-50 text-slate-600 hover:bg-slate-100'}`}>
                                                <span className="font-bold opacity-50">{w.number}.</span>
                                                <span className="text-sm font-medium line-clamp-1">{w.clue}</span>
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {status === 'victory' && (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-indigo-600/95 text-white p-8 text-center animate-fade-in backdrop-blur-sm">
                            <Confetti />
                            <Trophy size={80} className="text-yellow-300 mb-6 animate-bounce"/>
                            <h1 className="text-5xl font-black mb-4">춰Crucigrama Resuelto!</h1>
                            <div className="flex flex-col gap-3 w-full max-w-xs">
                                <button onClick={() => window.location.reload()} className="w-full py-4 bg-white text-indigo-600 rounded-xl font-bold flex items-center justify-center gap-2 hover:scale-105 transition-transform shadow-lg"><RotateCcw size={20}/> Jugar de Nuevo</button>
                                <button onClick={handleExit} className="w-full py-4 bg-indigo-800 text-indigo-200 rounded-xl font-bold flex items-center justify-center gap-2 hover:bg-indigo-900 border border-indigo-700">Volver al Men칰</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<CrosswordGame />);
    </script>
</body>
</html>
