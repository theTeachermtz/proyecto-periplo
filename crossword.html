<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Periplo - Crucigrama</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§©</text></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700;800&display=swap'); 
        body { font-family: 'Plus Jakarta Sans', sans-serif; background-color: #f8fafc; }
        
        .cw-cell { transition: all 0.2s; caret-color: transparent; }
        .cw-cell:focus { outline: none; background-color: #e0e7ff; border-color: #6366f1; transform: scale(1.05); z-index: 10; }
        .cw-cell.active-word { background-color: #eff6ff; }
        .cw-cell.correct { background-color: #dcfce7; color: #166534; border-color: #86efac; }
        
        @keyframes confetti { 0% { transform: translate(-50%, -50%) rotate(0deg); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) rotate(720deg); opacity: 0; } }
        .animate-confetti { animation: confetti 1s ease-out forwards; }
        .animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { initializeApp } from 'firebase/app';
        import { getFirestore, doc, getDoc } from 'firebase/firestore';
        import { ArrowLeft, RefreshCw, Check, X, Trophy, LogOut, Loader2, Pause, List, RotateCcw, ChevronRight } from 'lucide-react';

        const firebaseConfig = {
            apiKey: "AIzaSyD4d-Kx1jQbgrKIdeOftv7BM729m7MIGPo",
            authDomain: "proyecto-periplo.firebaseapp.com",
            projectId: "proyecto-periplo",
            storageBucket: "proyecto-periplo.firebasestorage.app",
            messagingSenderId: "236795998392",
            appId: "1:236795998392:web:0da24b4f018611b55c844d"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- ALGORITMO GENERADOR ROBUSTO ---
        class CrosswordGenerator {
            constructor(width = 15, height = 15) { // AUMENTADO A 15x15
                this.width = width;
                this.height = height;
                this.grid = Array(height).fill(null).map(() => Array(width).fill(null));
                this.placedWords = [];
            }

            generate(wordList) {
                const sortedWords = [...wordList]
                    .filter(w => w.front && w.front.length > 1)
                    .map(w => ({ ...w, answer: w.front.toUpperCase().replace(/[^A-Z]/g, ''), clue: w.back }))
                    .sort((a, b) => b.answer.length - a.answer.length); // MÃ¡s largas primero

                if (sortedWords.length === 0) return null;

                // 1. Colocar primera palabra (la mÃ¡s larga) en el centro
                const first = sortedWords[0];
                const startX = Math.floor((this.width - first.answer.length) / 2);
                const startY = Math.floor(this.height / 2);
                
                // SEGURIDAD: Si la primera palabra es mÃ¡s larga que el grid, abortar
                if (startX < 0) return null;

                this.placeWord(first, startX, startY, 'across');

                // 2. Intentar colocar las demÃ¡s
                for (let i = 1; i < sortedWords.length; i++) {
                    this.tryPlaceWord(sortedWords[i]);
                }
                
                // Si colocamos muy pocas palabras (menos de 2), considerar fallo
                if (this.placedWords.length < 2 && sortedWords.length > 2) return null;

                return this.exportData();
            }

            tryPlaceWord(wordObj) {
                const { answer } = wordObj;
                const bestPositions = [];

                for (const placed of this.placedWords) {
                    for (let i = 0; i < answer.length; i++) {
                        for (let j = 0; j < placed.answer.length; j++) {
                            if (answer[i] === placed.answer[j]) {
                                const newDir = placed.direction === 'across' ? 'down' : 'across';
                                let r, c;
                                if (newDir === 'down') { r = placed.row - i; c = placed.col + j; } 
                                else { r = placed.row + j; c = placed.col - i; }

                                if (this.canPlace(answer, r, c, newDir)) {
                                    bestPositions.push({ r, c, dir: newDir });
                                }
                            }
                        }
                    }
                }
                
                // Si hay opciones, tomamos la primera (greedy)
                if (bestPositions.length > 0) {
                    const pos = bestPositions[0];
                    this.placeWord(wordObj, pos.r, pos.c, pos.dir);
                    return true;
                }
                return false;
            }

            canPlace(word, row, col, direction) {
                if (row < 0 || col < 0) return false;
                
                if (direction === 'across') {
                    if (col + word.length > this.width) return false;
                    if (col - 1 >= 0 && this.grid[row][col - 1] !== null) return false;
                    if (col + word.length < this.width && this.grid[row][col + word.length] !== null) return false;
                    
                    for (let i = 0; i < word.length; i++) {
                        const cell = this.grid[row][col + i];
                        if (cell !== null && cell !== word[i]) return false;
                        if (cell === null) {
                            if (row - 1 >= 0 && this.grid[row - 1][col + i] !== null) return false;
                            if (row + 1 < this.height && this.grid[row + 1][col + i] !== null) return false;
                        }
                    }
                } else { // Down
                    if (row + word.length > this.height) return false;
                    if (row - 1 >= 0 && this.grid[row - 1][col] !== null) return false;
                    if (row + word.length < this.height && this.grid[row + word.length][col] !== null) return false;
                    
                    for (let i = 0; i < word.length; i++) {
                        const cell = this.grid[row + i][col];
                        if (cell !== null && cell !== word[i]) return false;
                        if (cell === null) {
                            if (col - 1 >= 0 && this.grid[row + i][col - 1] !== null) return false;
                            if (col + 1 < this.width && this.grid[row + i][col + 1] !== null) return false;
                        }
                    }
                }
                return true;
            }

            placeWord(wordObj, row, col, direction) {
                // SEGURIDAD: Verificar lÃ­mites antes de escribir
                if (row < 0 || col < 0 || row >= this.height || col >= this.width) return;

                const { answer } = wordObj;
                this.placedWords.push({ ...wordObj, row, col, direction });
                
                for (let i = 0; i < answer.length; i++) {
                    let r = row, c = col;
                    if (direction === 'across') c += i;
                    else r += i;

                    // DOBLE CHECK: Solo escribir si la celda existe
                    if (this.grid[r] && this.grid[r][c] !== undefined) {
                        this.grid[r][c] = answer[i];
                    }
                }
            }

            exportData() {
                this.placedWords.sort((a, b) => (a.row === b.row ? a.col - b.col : a.row - b.row));
                let currentNum = 1;
                const cells = {};
                this.placedWords.forEach((word) => {
                    const key = `${word.row}-${word.col}`;
                    if (!cells[key]) cells[key] = currentNum++;
                    word.number = cells[key];
                });
                return { width: this.width, height: this.height, words: this.placedWords, gridStructure: this.grid };
            }
        }

        // --- COMPONENTES ---
        const Confetti = () => {
            const colors = ['#6366f1', '#ec4899', '#10b981', '#f59e0b'];
            return (<div className="absolute inset-0 pointer-events-none z-50 overflow-hidden flex justify-center">{[...Array(40)].map((_, i) => (<div key={i} className="absolute w-2 h-2 rounded-full animate-confetti" style={{backgroundColor: colors[i % colors.length], left: '50%', top: '50%', '--tx': `${(Math.random()-0.5)*800}px`, '--ty': `${(Math.random()-1)*800}px`, animationDelay: `${Math.random()*0.5}s`}} />))}</div>);
        };

        const CrosswordGame = () => {
            const [loading, setLoading] = useState(true);
            const [gameData, setGameData] = useState(null);
            const [gridValues, setGridValues] = useState({});
            const [selectedCell, setSelectedCell] = useState(null);
            const [direction, setDirection] = useState('across');
            const [status, setStatus] = useState('playing');
            const [gameId, setGameId] = useState(null);
            const inputRefs = useRef({});

            useEffect(() => {
                const init = async () => {
                    const params = new URLSearchParams(window.location.search);
                    const id = params.get('id');
                    setGameId(id);
                    if (!id) return alert("Falta ID");

                    try {
                        const docRef = doc(db, 'artifacts/periplo-app-v1/users/teacher_builder_001/quizzes', id);
                        const snap = await getDoc(docRef);
                        if (snap.exists()) {
                            const data = snap.data();
                            // Intentar generar hasta 3 veces para encontrar un buen layout
                            let layout = null;
                            for(let i=0; i<3; i++) {
                                const gen = new CrosswordGenerator();
                                layout = gen.generate(data.questions);
                                if(layout) break;
                            }
                            
                            if (layout && layout.words.length > 0) {
                                setGameData(layout);
                                setSelectedCell({ r: layout.words[0].row, c: layout.words[0].col });
                            } else {
                                alert("No se pudo generar el crucigrama. Las palabras no se cruzan bien.");
                            }
                        }
                    } catch (e) { console.error(e); } finally { setLoading(false); }
                };
                init();
            }, []);

            // Auto-focus
            useEffect(() => {
                if (selectedCell && inputRefs.current[`${selectedCell.r}-${selectedCell.c}`]) {
                    inputRefs.current[`${selectedCell.r}-${selectedCell.c}`].focus();
                }
            }, [selectedCell]);

            const activeWord = useMemo(() => {
                if (!gameData || !selectedCell) return null;
                return gameData.words.find(w => {
                    const isAcross = w.direction === 'across' && direction === 'across';
                    const isDown = w.direction === 'down' && direction === 'down';
                    if (isAcross) return w.row === selectedCell.r && selectedCell.c >= w.col && selectedCell.c < w.col + w.answer.length;
                    if (isDown) return w.col === selectedCell.c && selectedCell.r >= w.row && selectedCell.r < w.row + w.answer.length;
                    return false;
                });
            }, [gameData, selectedCell, direction]);

            // Check Win
            useEffect(() => {
                if (!gameData) return;
                const isComplete = gameData.words.every(w => {
                    for (let i = 0; i < w.answer.length; i++) {
                        const r = w.direction === 'across' ? w.row : w.row + i;
                        const c = w.direction === 'across' ? w.col + i : w.col;
                        if (gridValues[`${r}-${c}`] !== w.answer[i]) return false;
                    }
                    return true;
                });
                if (isComplete && status !== 'victory') setStatus('victory');
            }, [gridValues]);

            const handleCellClick = (r, c) => {
                if (selectedCell?.r === r && selectedCell?.c === c) {
                    setDirection(prev => prev === 'across' ? 'down' : 'across');
                } else {
                    setSelectedCell({ r, c });
                }
            };

            const handleInput = (val, r, c) => {
                const char = val.slice(-1).toUpperCase();
                setGridValues(p => ({ ...p, [`${r}-${c}`]: char }));
                
                if (char) {
                    const dr = direction === 'across' ? 0 : 1;
                    const dc = direction === 'across' ? 1 : 0;
                    if (gameData.gridStructure[r+dr]?.[c+dc] !== null && gameData.gridStructure[r+dr]?.[c+dc] !== undefined) {
                        setSelectedCell({ r: r + dr, c: c + dc });
                    }
                }
            };

            const handleKeyDown = (e, r, c) => {
                if (e.key === 'Backspace') {
                    if (!gridValues[`${r}-${c}`]) {
                        const dr = direction === 'across' ? 0 : 1;
                        const dc = direction === 'across' ? 1 : 0;
                        if (gameData.gridStructure[r-dr]?.[c-dc] !== null) {
                            setSelectedCell({ r: r - dr, c: c - dc });
                        }
                    } else {
                        setGridValues(p => { const copy = {...p}; delete copy[`${r}-${c}`]; return copy; });
                    }
                }
            };

            const handleExit = () => {
                // Volver a activity.html
                window.location.href = `activity.html?id=${gameId}`; 
            };

            if (loading) return <div className="h-screen flex items-center justify-center text-indigo-500 font-bold gap-2"><Loader2 className="animate-spin" size={32}/> GENERANDO TABLERO...</div>;
            if (!gameData) return <div className="h-screen flex items-center justify-center flex-col gap-4 text-slate-500"><AlertCircle size={48}/><p>No se pudo crear el crucigrama con estas palabras.</p><button onClick={handleExit} className="bg-slate-200 px-6 py-2 rounded-xl">Volver</button></div>;

            return (
                <div className="h-screen flex flex-col bg-slate-50 overflow-hidden">
                    {/* Header */}
                    <div className="h-16 bg-white shadow-sm flex items-center justify-between px-6 z-10 shrink-0">
                        <div className="font-black text-indigo-600 text-sm tracking-widest uppercase">CRUCIGRAMA</div>
                        <button onClick={handleExit} className="flex gap-2 items-center text-xs font-bold text-slate-400 hover:text-rose-500 uppercase">Salir <LogOut size={16}/></button>
                    </div>

                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden max-w-7xl mx-auto w-full">
                        
                        {/* GRID AREA */}
                        <div className="flex-1 flex items-center justify-center p-4 overflow-auto bg-slate-100/50">
                            <div 
                                className="grid gap-px bg-slate-300 border-[4px] border-slate-800 p-2 rounded-xl shadow-2xl bg-slate-800"
                                style={{ gridTemplateColumns: `repeat(${gameData.width}, minmax(0, 1fr))`, width: '100%', maxWidth: '650px', aspectRatio: `${gameData.width}/${gameData.height}` }}
                            >
                                {Array.from({ length: gameData.height }).map((_, r) => (
                                    Array.from({ length: gameData.width }).map((_, c) => {
                                        const cellData = gameData.gridStructure[r][c];
                                        if (cellData === null) return <div key={`${r}-${c}`} className="bg-slate-800/50"></div>;
                                        
                                        const wordStart = gameData.words.find(w => w.row === r && w.col === c);
                                        const isSelected = selectedCell?.r === r && selectedCell?.c === c;
                                        const isActiveWord = activeWord && ((activeWord.direction === 'across' && r === activeWord.row && c >= activeWord.col && c < activeWord.col + activeWord.answer.length) || (activeWord.direction === 'down' && c === activeWord.col && r >= activeWord.row && r < activeWord.row + activeWord.answer.length));
                                        const isCorrect = status === 'victory' || gridValues[`${r}-${c}`] === cellData;

                                        return (
                                            <div key={`${r}-${c}`} className={`relative flex items-center justify-center transition-colors duration-100 ${isSelected ? 'bg-yellow-200' : isActiveWord ? 'bg-indigo-100' : 'bg-white'}`}>
                                                {wordStart && <span className="absolute top-0.5 left-0.5 text-[8px] md:text-[10px] font-bold text-slate-500 leading-none select-none">{wordStart.number}</span>}
                                                <input 
                                                    ref={el => inputRefs.current[`${r}-${c}`] = el}
                                                    type="text" maxLength="1" 
                                                    value={gridValues[`${r}-${c}`] || ''}
                                                    onChange={(e) => handleInput(e.target.value, r, c)}
                                                    onKeyDown={(e) => handleKeyDown(e, r, c)}
                                                    className={`w-full h-full text-center font-black uppercase bg-transparent outline-none text-lg md:text-2xl ${status==='victory'?'text-emerald-600':'text-slate-800'}`}
                                                />
                                            </div>
                                        );
                                    })
                                ))}
                            </div>
                        </div>

                        {/* CLUES PANEL */}
                        <div className="h-1/3 md:h-full md:w-96 bg-white border-l border-slate-200 flex flex-col shadow-2xl z-20">
                            <div className="p-6 border-b bg-indigo-50/50">
                                <span className="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-2 block">PISTA ACTUAL</span>
                                {activeWord ? (
                                    <div className="flex items-start gap-4 animate-fade-in">
                                        <div className="w-10 h-10 bg-indigo-600 rounded-full flex items-center justify-center text-white font-bold shrink-0 text-lg shadow-lg">{activeWord.number}</div>
                                        <div className="flex-1">
                                            <p className="font-bold text-slate-800 text-xl leading-tight">{activeWord.clue}</p>
                                            <span className="text-xs font-bold text-indigo-400 uppercase mt-1 block">{activeWord.direction === 'across' ? 'Horizontal' : 'Vertical'}</span>
                                            {activeWord.image && <div className="mt-3 h-32 rounded-xl overflow-hidden border-2 border-white shadow-md bg-white"><img src={activeWord.image} className="h-full w-full object-contain" /></div>}
                                        </div>
                                    </div>
                                ) : <div className="text-slate-400 italic text-sm py-4 text-center">Selecciona una casilla para ver la pista</div>}
                            </div>
                            
                            <div className="flex-1 overflow-y-auto p-6 space-y-6 bg-slate-50">
                                {['across', 'down'].map(dir => {
                                    const words = gameData.words.filter(w => w.direction === dir).sort((a,b) => a.number - b.number);
                                    if(words.length === 0) return null;
                                    return (
                                        <div key={dir}>
                                            <h4 className="text-xs font-black text-slate-400 uppercase mb-3 flex items-center gap-2">
                                                {dir === 'across' ? <ArrowLeft className="rotate-180" size={14}/> : <ArrowLeft className="-rotate-90" size={14}/>} 
                                                {dir === 'across' ? 'Horizontales' : 'Verticales'}
                                            </h4>
                                            <div className="space-y-2">
                                                {words.map((w, i) => (
                                                    <button 
                                                        key={i} 
                                                        onClick={() => { setSelectedCell({r: w.row, c: w.col}); setDirection(w.direction); }}
                                                        className={`w-full text-left p-3 rounded-xl border transition-all flex gap-3 group ${activeWord === w ? 'bg-indigo-600 text-white border-indigo-600 shadow-md' : 'bg-white text-slate-600 border-slate-200 hover:border-indigo-300'}`}
                                                    >
                                                        <span className={`font-bold ${activeWord === w ? 'text-indigo-200' : 'text-slate-400 group-hover:text-indigo-500'}`}>{w.number}.</span>
                                                        <span className="text-sm font-bold line-clamp-1">{w.clue}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    </div>

                    {/* VICTORY MODAL */}
                    {status === 'victory' && (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-indigo-900/95 text-white p-8 text-center animate-fade-in backdrop-blur-sm">
                            <Confetti />
                            <div className="w-24 h-24 bg-yellow-400 rounded-full flex items-center justify-center mb-8 shadow-[0_0_40px_rgba(250,204,21,0.6)] animate-bounce">
                                <Trophy size={48} className="text-yellow-900" />
                            </div>
                            <h1 className="text-6xl font-black mb-4 tracking-tight">Â¡IMPECABLE!</h1>
                            <p className="text-2xl text-indigo-200 mb-10 font-medium">Has completado el crucigrama.</p>
                            <div className="flex flex-col gap-4 w-full max-w-sm">
                                <button onClick={() => window.location.reload()} className="w-full py-4 bg-white text-indigo-900 rounded-2xl font-black flex items-center justify-center gap-2 hover:scale-105 transition-transform shadow-xl uppercase tracking-wider"><RotateCcw size={20}/> Jugar de Nuevo</button>
                                <button onClick={handleExit} className="w-full py-4 bg-indigo-800 text-indigo-300 rounded-2xl font-bold flex items-center justify-center gap-2 hover:bg-indigo-700 hover:text-white transition-colors uppercase tracking-widest">Volver al MenÃº</button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<CrosswordGame />);
    </script>
</body>
</html>
